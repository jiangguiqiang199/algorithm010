学习笔记

学习方法总结：
1、不要死扣，第一遍没有思路，直接砍答案。

2、学习高手解题思路。

3、学习完成后徒手自己写一遍。

4、第二天，自己再徒手写一遍。

5、面试前，再恢复训练一次。


算法处理套路：

1、找出重复的逻辑。

2、整个编程无非就是：if else | for | while |  递归

3、通过if else | for | while |  递归  排列组合重复逻辑  得出复杂逻辑。
--------------------------------------------------------------------------------
删除排序数组中的重复项：
1、一点思路没有。

2、学习官方解题思路：
   2.1、一个慢指针i，一个快指针j
   2.2、后一个元素跟前一个元素比较，如果后元素和前元素相等，则将后面元素的值赋给前面的元素。快指针往前走，慢指针先不动。
   2.3、后一个元素跟前一个元素比较，如果后元素和前元素不相等，则快指针和慢指针都往前走一步。
   
3、关键点：该数组是排好序的

4、重复逻辑: 慢指针跟快指针比较，慢指针和快指针相等的话，快指针赋值给慢指针，快指针往前走，慢指针不动。
后置跟前值不相等的话，慢指针和快指针都往前走   
   
3、理解思路后，徒手写一遍   
public int removeDuplicates(int[] nums) {
         // 任何函数进来，先把入参校验一遍。
        if(nums.length=0){
            return 0;
        }
        // 定义慢指针i
        int i=0;
        // 循环快指针
        for(int j=1;j<nums.length-1;i++){
            if(nums[i] != nums[j]){
			    // 我们俩如果不相等，我们一起往前走一步
                i++;
            }else{
			    // 如果我们俩相等，你把值给我，我原地不动，你继续往前走一步
                // 第i个元素和第j个元素相等，将第i个元素的值赋值成第j个元素的值
                nums[i] = nums[j];
            }
        }
    }